# EZTraveler Authentication & Authorization Setup Guide

## Overview

This document outlines the technical implementation for authentication and authorization in the EZTraveler OTA (Online Travel Agency) platform. The system supports two distinct user roles with separate access patterns and security requirements.

## System Architecture

### User Roles
1. **User Role** (`user`)
   - Access to personal dashboard at `/dashboard`
   - Can book trips, view bookings, manage profile
   - Cannot access admin functions

2. **Admin Role** (`admin`)
   - Access to admin panel at `/admin`
   - Can manage all user bookings, process refunds, change dates
   - Cannot access user dashboard (to prevent confusion and maintain separation of concerns)

## Development Principles

### 1. Type Safety First
- Use TypeScript strictly with no `any` types
- Define all data models with proper validators
- Use Zod for runtime validation
- Leverage Convex's type generation for end-to-end type safety

### 2. Security by Design
- Role-based access control (RBAC) at database level
- Route protection at both frontend and backend
- Session validation on every request
- Secure password requirements with proper validation

### 3. UI/UX Standards
- Use Shadcn UI components exclusively
- Leverage CSS variables for theming (never hardcode colors)
- Consistent spacing using Tailwind's spacing scale
- Responsive design with mobile-first approach

### 4. Code Organization
```
src/
├── components/
│   ├── auth/
│   │   ├── SignInForm.tsx
│   │   ├── SignUpForm.tsx
│   │   ├── PasswordReset.tsx
│   │   └── AuthLayout.tsx
│   ├── dashboard/
│   │   ├── UserDashboard.tsx
│   │   └── BookingList.tsx
│   ├── admin/
│   │   ├── AdminDashboard.tsx
│   │   ├── UserManagement.tsx
│   │   └── BookingManagement.tsx
│   └── ui/          # Shadcn components
├── lib/
│   ├── auth/
│   │   ├── hooks.ts
│   │   └── utils.ts
│   ├── validators/
│   │   ├── auth.ts
│   │   └── booking.ts
│   └── utils.ts
├── routes/
│   ├── auth/
│   ├── dashboard/
│   └── admin/
└── styles/
    └── globals.css
```

## Detailed Directory Structure

### Complete Project Structure

```
eztraveler/
├── convex/                      # Backend (Convex functions)
│   ├── _generated/              # Auto-generated by Convex
│   ├── auth/                    # Authentication related functions
│   │   ├── config.ts            # Auth provider configuration
│   │   ├── emailVerification.ts # Email verification logic
│   │   └── passwordReset.ts     # Password reset logic
│   ├── users/                   # User management
│   │   ├── mutations.ts         # User CRUD operations
│   │   ├── queries.ts           # User data queries
│   │   └── helpers.ts           # User-related utilities
│   ├── bookings/                # Booking management
│   │   ├── mutations.ts         # Booking CRUD operations
│   │   ├── queries.ts           # Booking data queries
│   │   └── validators.ts        # Booking validation schemas
│   ├── admin/                   # Admin-specific functions
│   │   ├── userManagement.ts    # Admin user operations
│   │   ├── bookingManagement.ts # Admin booking operations
│   │   └── analytics.ts         # Admin analytics queries
│   ├── auth.ts                  # Main auth configuration
│   ├── schema.ts                # Database schema
│   └── http.ts                  # HTTP endpoints (webhooks, etc.)
│
├── src/
│   ├── components/              # Reusable UI components
│   │   ├── auth/                # Authentication components
│   │   │   ├── SignInForm.tsx
│   │   │   ├── SignUpForm.tsx
│   │   │   ├── PasswordResetForm.tsx
│   │   │   ├── EmailVerificationForm.tsx
│   │   │   ├── AuthLayout.tsx   # Layout wrapper for auth pages
│   │   ├── booking/             # Booking-related components
│   │   │   ├── BookingCard.tsx
│   │   │   ├── BookingForm.tsx
│   │   │   ├── BookingDetails.tsx
│   │   │   ├── HotelSearch.tsx
│   │   │   └── DatePicker.tsx
│   │   ├── dashboard/           # User dashboard components
│   │   │   ├── DashboardLayout.tsx
│   │   │   ├── BookingList.tsx
│   │   │   ├── UserProfile.tsx
│   │   │   ├── TripHistory.tsx
│   │   │   └── QuickActions.tsx
│   │   ├── admin/               # Admin panel components
│   │   │   ├── AdminLayout.tsx
│   │   │   ├── UserTable.tsx
│   │   │   ├── BookingTable.tsx
│   │   │   ├── RefundModal.tsx
│   │   │   ├── DateChangeModal.tsx
│   │   │   └── Analytics.tsx
│   │   ├── shared/              # Shared components
│   │   │   ├── Header.tsx
│   │   │   ├── Footer.tsx
│   │   │   ├── Navigation.tsx
│   │   │   ├── LoadingSpinner.tsx
│   │   │   ├── ErrorBoundary.tsx
│   │   │   └── NotFound.tsx
│   │   └── ui/                  # Shadcn UI components
│   │       ├── button.tsx
│   │       ├── card.tsx
│   │       ├── dialog.tsx
│   │       ├── form.tsx
│   │       ├── input.tsx
│   │       ├── table.tsx
│   │       ├── toast.tsx
│   │       └── ... (other shadcn components)
│   │
│   ├── hooks/                   # Custom React hooks
│   │   ├── auth/
│   │   │   ├── useAuth.ts       # Auth state management
│   │   │   ├── useRole.ts       # Role-based logic
│   │   │   └── useSession.ts    # Session management
│   │   ├── booking/
│   │   │   ├── useBookings.ts   # Booking data hooks
│   │   │   └── useHotelSearch.ts
│   │   ├── useDebounce.ts
│   │   ├── useLocalStorage.ts
│   │   └── useMediaQuery.ts
│   │
│   ├── lib/                     # Utility libraries
│   │   ├── auth/
│   │   │   ├── ProtectedRoute.tsx
│   │   │   ├── permissions.ts   # Permission constants
│   │   │   └── utils.ts         # Auth utilities
│   │   ├── validators/          # Zod schemas
│   │   │   ├── auth.ts
│   │   │   ├── booking.ts
│   │   │   ├── user.ts
│   │   │   └── common.ts
│   │   ├── constants/           # App constants
│   │   │   ├── routes.ts
│   │   │   ├── messages.ts
│   │   │   └── config.ts
│   │   ├── formatters/          # Data formatters
│   │   │   ├── date.ts
│   │   │   ├── currency.ts
│   │   │   └── user.ts
│   │   ├── api/                 # API helpers (if needed)
│   │   │   └── external.ts      # External API integrations
│   │   └── utils.ts             # General utilities
│   │
│   ├── routes/                  # Page components (route-based)
│   │   ├── auth/
│   │   │   ├── SignIn.tsx
│   │   │   ├── SignUp.tsx
│   │   │   ├── PasswordReset.tsx
│   │   │   ├── VerifyEmail.tsx
│   │   │   └── index.tsx        # Auth route wrapper
│   │   ├── dashboard/
│   │   │   ├── index.tsx        # Dashboard home
│   │   │   ├── Bookings.tsx
│   │   │   ├── NewBooking.tsx
│   │   │   ├── BookingDetails.tsx
│   │   │   ├── Profile.tsx
│   │   │   └── Settings.tsx
│   │   ├── admin/
│   │   │   ├── index.tsx        # Admin home
│   │   │   ├── Users.tsx
│   │   │   ├── UserDetails.tsx
│   │   │   ├── Bookings.tsx
│   │   │   ├── BookingDetails.tsx
│   │   │   ├── Analytics.tsx
│   │   │   └── Settings.tsx
│   │   ├── public/              # Public pages
│   │   │   ├── Landing.tsx
│   │   │   ├── About.tsx
│   │   │   └── Contact.tsx
│   │   ├── Unauthorized.tsx
│   │   └── NotFound.tsx
│   │
│   ├── App.tsx                  # Main app component
│   ├── main.tsx                 # App entry point
│   └── vite-env.d.ts           # Vite types
│
```

### Directory Purpose Guide

#### `/convex` - Backend Logic
- **auth/**: Authentication-specific backend logic
- **users/**: User-related queries and mutations
- **bookings/**: Booking business logic
- **admin/**: Admin-only backend functions
- Keep functions small and focused
- Group by domain, not by function type

#### `/src/components` - UI Components
- **Reusable components only** - no page-specific logic
- **auth/**: Login forms, password reset, etc.
- **booking/**: Booking cards, forms, search components
- **dashboard/**: User dashboard widgets
- **admin/**: Admin-specific UI components
- **shared/**: Components used across roles
- **ui/**: Shadcn UI base components

#### `/src/routes` - Page Components
- **One file per route**
- Contains page-level logic and layout
- Composes smaller components
- Handles route-specific data fetching
- Named after their URL path

#### `/src/hooks` - Custom Hooks
- **Reusable React logic**
- Auth state management
- Data fetching abstractions
- UI state hooks (modals, toggles)
- Always prefix with `use`

#### `/src/lib` - Utilities & Helpers
- **Non-React utilities**
- Validation schemas (Zod)
- Constants and configuration
- Formatting functions
- Permission matrices

### File Naming Conventions

1. **Components**: PascalCase (e.g., `BookingCard.tsx`)
2. **Hooks**: camelCase with `use` prefix (e.g., `useAuth.ts`)
3. **Utilities**: camelCase (e.g., `formatDate.ts`)
4. **Types**: PascalCase for interfaces/types (e.g., `User.ts`)
5. **Constants**: UPPER_SNAKE_CASE in files (e.g., `API_ENDPOINTS`)
6. **Convex Functions**: camelCase (e.g., `createBooking.ts`)

### Import Order

```typescript
// 1. External imports
import React from "react";
import { useQuery } from "convex/react";

// 2. Internal imports - absolute paths
import { Button } from "@/components/ui/button";
import { useAuth } from "@/hooks/auth/useAuth";

// 3. Relative imports
import { BookingCard } from "./BookingCard";

```

### Key Principles

1. **Separation of Concerns**
   - Backend logic in `/convex`
   - UI components in `/src/components`
   - Page logic in `/src/routes`

2. **Reusability**
   - Components should be role-agnostic when possible
   - Use composition over duplication

3. **Type Safety**
   - Every file should be TypeScript
   - No `any` types allowed
   - Use generated Convex types

4. **Scalability**
   - Group by feature/domain
   - Keep files focused and small
   - Easy to find related code

## Authentication Implementation

### 1. Convex Schema Setup

```typescript
// convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
import { authTables } from "@convex-dev/auth/server";

export default defineSchema({
  ...authTables,
  users: defineTable({
    // Email and password are handled by auth tables
    email: v.optional(v.string()),
    name: v.optional(v.string()),
    role: v.optional(v.union(v.literal("user"), v.literal("admin"))),
    isActive: v.optional(v.boolean()),
    emailVerified: v.optional(v.boolean()),
    
    // Profile fields
    phoneNumber: v.optional(v.string()),
    profileImage: v.optional(v.string()),
    
    // Timestamps - these are optional because auth system creates users
    createdAt: v.optional(v.number()),
    updatedAt: v.optional(v.number()),
  })
    .index("by_email", ["email"])
    .index("by_role", ["role"]),
    
  bookings: defineTable({
    userId: v.id("users"),
    hotelId: v.string(),
    hotelName: v.string(),
    checkIn: v.string(), // ISO date string
    checkOut: v.string(), // ISO date string
    guests: v.number(),
    rooms: v.number(),
    totalAmount: v.number(),
    status: v.union(
      v.literal("pending"),
      v.literal("confirmed"),
      v.literal("cancelled"),
      v.literal("completed")
    ),
    paymentId: v.optional(v.string()),
    notes: v.optional(v.string()),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_status", ["status"])
    .index("by_user_and_status", ["userId", "status"]),
});
```

### 2. Authentication Configuration

```typescript
// convex/auth.config.ts
import { Password } from "@convex-dev/auth/providers/Password";
import { ConvexError } from "convex/values";
import { z } from "zod";
import { DataModel } from "./_generated/dataModel";

// Email validation schema
const EmailSchema = z.string().email().toLowerCase();

// Password validation schema
const PasswordSchema = z
  .string()
  .min(8, "Password must be at least 8 characters")
  .regex(/[A-Z]/, "Password must contain at least one uppercase letter")
  .regex(/[a-z]/, "Password must contain at least one lowercase letter")
  .regex(/[0-9]/, "Password must contain at least one number")
  .regex(/[^A-Za-z0-9]/, "Password must contain at least one special character");

// Sign up params validation
const SignUpSchema = z.object({
  email: EmailSchema,
  password: PasswordSchema,
  name: z.string().min(2, "Name must be at least 2 characters"),
  role: z.enum(["user", "admin"]).default("user"),
});

export const PasswordProvider = Password<DataModel>({
  profile(params) {
    // Validate sign-up data
    const result = SignUpSchema.safeParse(params);
    if (!result.success) {
      throw new ConvexError(result.error.format());
    }

    const { email, name, role } = result.data;
    
    return {
      email,
      name,
      role,
      emailVerified: false,
      isActive: true,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
  },
  
  validatePasswordRequirements(password: string) {
    const result = PasswordSchema.safeParse(password);
    if (!result.success) {
      throw new ConvexError("Password does not meet requirements");
    }
  },
});
```

### 3. Simplified Authentication Setup

```typescript
// convex/auth.ts
import { convexAuth } from "@convex-dev/auth/server";
import { Password } from "@convex-dev/auth/providers/Password";
import { DataModel } from "./_generated/dataModel";
import { ConvexError } from "convex/values";

// Simple password provider with role support
const PasswordWithRole = Password<DataModel>({
  profile(params) {
    const email = params.email as string;
    const name = params.name as string;
    const role = (params.role as "user" | "admin") || "user";
    
    // Validate email format
    if (!email || !email.includes("@")) {
      throw new ConvexError("Invalid email address");
    }
    
    // Validate name
    if (!name || name.length < 2) {
      throw new ConvexError("Name must be at least 2 characters");
    }
    
    return {
      email: email.toLowerCase(),
      name,
      role,
      isActive: true,
      emailVerified: true, // Set to true for simplicity, change if email verification is needed
    };
  },
  
  validatePasswordRequirements(password: string) {
    // Simple password validation
    if (!password || password.length < 8) {
      throw new ConvexError("Password must be at least 8 characters");
    }
    
    // Optional: Add more complex validation
    if (!/[A-Z]/.test(password)) {
      throw new ConvexError("Password must contain at least one uppercase letter");
    }
    if (!/[a-z]/.test(password)) {
      throw new ConvexError("Password must contain at least one lowercase letter");
    }
    if (!/[0-9]/.test(password)) {
      throw new ConvexError("Password must contain at least one number");
    }
  },
});

export const { auth, signIn, signOut, store, isAuthenticated } = convexAuth({
  providers: [PasswordWithRole],
});
```

### 4. HTTP Routes Configuration

```typescript
// convex/http.ts
import { httpRouter } from "convex/server";
import { auth } from "./auth";

const http = httpRouter();

// Add auth routes (handles sign-in, sign-out, etc.)
auth.addHttpRoutes(http);

export default http;
```

### 5. User Management Functions

```typescript
// convex/users/queries.ts
import { query } from "../_generated/server";
import { v } from "convex/values";
import { getAuthUserId } from "@convex-dev/auth/server";

export const getCurrentUser = query({
  args: {},
  returns: v.union(
    v.null(),
    v.object({
      _id: v.id("users"),
      email: v.string(),
      name: v.string(),
      role: v.union(v.literal("user"), v.literal("admin")),
      isActive: v.boolean(),
      emailVerified: v.boolean(),
    })
  ),
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      return null;
    }
    
    const user = await ctx.db.get(userId);
    if (!user || !user.isActive) {
      return null;
    }
    
    return {
      _id: user._id,
      email: user.email!,
      name: user.name!,
      role: user.role as "user" | "admin",
      isActive: user.isActive,
      emailVerified: user.emailVerified || false,
    };
  },
});

export const getUserById = query({
  args: { userId: v.id("users") },
  returns: v.union(
    v.null(),
    v.object({
      _id: v.id("users"),
      email: v.string(),
      name: v.string(),
      role: v.union(v.literal("user"), v.literal("admin")),
    })
  ),
  handler: async (ctx, args) => {
    const currentUser = await getCurrentUser(ctx, {});
    if (!currentUser) {
      throw new ConvexError("Unauthorized");
    }
    
    // Only admins can query other users
    if (currentUser.role !== "admin" && currentUser._id !== args.userId) {
      throw new ConvexError("Access denied");
    }
    
    const user = await ctx.db.get(args.userId);
    if (!user) {
      return null;
    }
    
    return {
      _id: user._id,
      email: user.email!,
      name: user.name!,
      role: user.role as "user" | "admin",
    };
  },
});
```

### 6. Helper Functions for Role-Based Access

```typescript
// convex/auth/helpers.ts
import { ConvexError } from "convex/values";
import { getAuthUserId } from "@convex-dev/auth/server";
import { QueryCtx, MutationCtx, ActionCtx } from "../_generated/server";

type Context = QueryCtx | MutationCtx | ActionCtx;

export const requireAuth = async (ctx: Context) => {
  const userId = await getAuthUserId(ctx);
  if (!userId) {
    throw new ConvexError("Authentication required");
  }
  
  const user = await ctx.db.get(userId);
  if (!user || !user.isActive) {
    throw new ConvexError("User not found or inactive");
  }
  
  return user;
};

export const requireUser = async (ctx: Context) => {
  const user = await requireAuth(ctx);
  
  if (user.role !== "user") {
    throw new ConvexError("User access required");
  }
  
  return user;
};

export const requireAdmin = async (ctx: Context) => {
  const user = await requireAuth(ctx);
  
  if (user.role !== "admin") {
    throw new ConvexError("Admin access required");
  }
  
  return user;
};
```

## Frontend Implementation

### 1. Authentication Forms

```typescript
// src/components/auth/SignInForm.tsx
import { useState } from "react";
import { useAuthActions } from "@convex-dev/auth/react";
import { useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Loader2 } from "lucide-react";

export function SignInForm() {
  const { signIn } = useAuthActions();
  const navigate = useNavigate();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const formData = new FormData(e.currentTarget);
    
    try {
      await signIn("password", formData);
      navigate("/dashboard");
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to sign in");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Card className="w-full max-w-md">
      <CardHeader>
        <CardTitle>Sign In</CardTitle>
        <CardDescription>
          Enter your email and password to access your account
        </CardDescription>
      </CardHeader>
      <form onSubmit={handleSubmit}>
        <CardContent className="space-y-4">
          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          
          <div className="space-y-2">
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              name="email"
              type="email"
              placeholder="name@example.com"
              required
              disabled={isLoading}
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              name="password"
              type="password"
              required
              disabled={isLoading}
            />
          </div>
          
          <input type="hidden" name="flow" value="signIn" />
        </CardContent>
        
        <CardFooter className="flex flex-col space-y-2">
          <Button 
            type="submit" 
            className="w-full" 
            disabled={isLoading}
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Signing in...
              </>
            ) : (
              "Sign In"
            )}
          </Button>
          
          <p className="text-sm text-muted-foreground text-center">
            Don't have an account?{" "}
            <a href="/auth/signup" className="text-primary hover:underline">
              Sign up
            </a>
          </p>
        </CardFooter>
      </form>
    </Card>
  );
}
```

```typescript
// src/components/auth/SignUpForm.tsx
import { useState } from "react";
import { useAuthActions } from "@convex-dev/auth/react";
import { useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Loader2 } from "lucide-react";

export function SignUpForm() {
  const { signIn } = useAuthActions();
  const navigate = useNavigate();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const formData = new FormData(e.currentTarget);
    
    // Password confirmation check
    const password = formData.get("password") as string;
    const confirmPassword = formData.get("confirmPassword") as string;
    
    if (password !== confirmPassword) {
      setError("Passwords do not match");
      setIsLoading(false);
      return;
    }
    
    try {
      await signIn("password", formData);
      navigate("/dashboard");
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to create account");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Card className="w-full max-w-md">
      <CardHeader>
        <CardTitle>Create Account</CardTitle>
        <CardDescription>
          Sign up to start booking your trips
        </CardDescription>
      </CardHeader>
      <form onSubmit={handleSubmit}>
        <CardContent className="space-y-4">
          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          
          <div className="space-y-2">
            <Label htmlFor="name">Full Name</Label>
            <Input
              id="name"
              name="name"
              type="text"
              placeholder="John Doe"
              required
              disabled={isLoading}
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              name="email"
              type="email"
              placeholder="name@example.com"
              required
              disabled={isLoading}
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              name="password"
              type="password"
              required
              disabled={isLoading}
            />
            <p className="text-xs text-muted-foreground">
              Must be at least 8 characters with uppercase, lowercase, and number
            </p>
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="confirmPassword">Confirm Password</Label>
            <Input
              id="confirmPassword"
              name="confirmPassword"
              type="password"
              required
              disabled={isLoading}
            />
          </div>
          
          <input type="hidden" name="flow" value="signUp" />
          <input type="hidden" name="role" value="user" />
        </CardContent>
        
        <CardFooter className="flex flex-col space-y-2">
          <Button 
            type="submit" 
            className="w-full" 
            disabled={isLoading}
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Creating account...
              </>
            ) : (
              "Create Account"
            )}
          </Button>
          
          <p className="text-sm text-muted-foreground text-center">
            Already have an account?{" "}
            <a href="/auth/signin" className="text-primary hover:underline">
              Sign in
            </a>
          </p>
        </CardFooter>
      </form>
    </Card>
  );
}
```

### 2. Authentication Hook

```typescript
// src/hooks/auth/useAuth.ts
import { useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";
import { useAuthActions } from "@convex-dev/auth/react";

export function useAuth() {
  const user = useQuery(api.users.getCurrentUser);
  const { signOut } = useAuthActions();
  
  return {
    user,
    isAuthenticated: !!user,
    isLoading: user === undefined,
    isUser: user?.role === "user",
    isAdmin: user?.role === "admin",
    signOut,
  };
}
```

### 3. Protected Route Component

```typescript
// src/lib/auth/ProtectedRoute.tsx
import { Navigate, useLocation } from "react-router-dom";
import { useAuth } from "@/hooks/auth/useAuth";
import { Loader2 } from "lucide-react";

interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRole: "user" | "admin";
}

export function ProtectedRoute({ children, requiredRole }: ProtectedRouteProps) {
  const location = useLocation();
  const { user, isLoading } = useAuth();
  
  // Loading state
  if (isLoading) {
    return (
      <div className="flex h-screen items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }
  
  // Not authenticated
  if (!user) {
    return <Navigate to="/auth/signin" state={{ from: location }} replace />;
  }
  
  // Wrong role
  if (user.role !== requiredRole) {
    return <Navigate to="/unauthorized" replace />;
  }
  
  return <>{children}</>;
}
```

### 4. App Router Configuration

```typescript
// src/App.tsx
import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
import { ConvexProvider, ConvexReactClient } from "convex/react";
import { ConvexAuthProvider } from "@convex-dev/auth/react";
import { ProtectedRoute } from "@/lib/auth/ProtectedRoute";

// Auth pages
import { SignIn } from "@/routes/auth/SignIn";
import { SignUp } from "@/routes/auth/SignUp";

// User pages
import { UserDashboard } from "@/routes/dashboard/Dashboard";
import { Bookings } from "@/routes/dashboard/Bookings";
import { Profile } from "@/routes/dashboard/Profile";

// Admin pages
import { AdminDashboard } from "@/routes/admin/Dashboard";
import { UserManagement } from "@/routes/admin/UserManagement";
import { BookingManagement } from "@/routes/admin/BookingManagement";

// Other pages
import { Unauthorized } from "@/routes/Unauthorized";
import { NotFound } from "@/routes/NotFound";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL);

export default function App() {
  return (
    <ConvexProvider client={convex}>
      <ConvexAuthProvider>
        <BrowserRouter>
          <Routes>
            {/* Public routes */}
            <Route path="/" element={<Navigate to="/dashboard" replace />} />
            
            {/* Auth routes */}
            <Route path="/auth">
              <Route path="signin" element={<SignIn />} />
              <Route path="signup" element={<SignUp />} />
            </Route>
            
            {/* User routes */}
            <Route
              path="/dashboard"
              element={
                <ProtectedRoute requiredRole="user">
                  <UserDashboard />
                </ProtectedRoute>
              }
            >
              <Route index element={<Bookings />} />
              <Route path="bookings" element={<Bookings />} />
              <Route path="profile" element={<Profile />} />
            </Route>
            
            {/* Admin routes */}
            <Route
              path="/admin"
              element={
                <ProtectedRoute requiredRole="admin">
                  <AdminDashboard />
                </ProtectedRoute>
              }
            >
              <Route index element={<BookingManagement />} />
              <Route path="bookings" element={<BookingManagement />} />
              <Route path="users" element={<UserManagement />} />
            </Route>
            
            {/* Error routes */}
            <Route path="/unauthorized" element={<Unauthorized />} />
            <Route path="*" element={<NotFound />} />
          </Routes>
        </BrowserRouter>
      </ConvexAuthProvider>
    </ConvexProvider>
  );
}
```

### 5. Example Protected API Usage

```typescript
// convex/bookings/mutations.ts
import { mutation } from "../_generated/server";
import { v } from "convex/values";
import { requireUser } from "../auth/helpers";

export const createBooking = mutation({
  args: {
    hotelId: v.string(),
    hotelName: v.string(),
    checkIn: v.string(),
    checkOut: v.string(),
    guests: v.number(),
    rooms: v.number(),
    totalAmount: v.number(),
  },
  returns: v.id("bookings"),
  handler: async (ctx, args) => {
    // Ensure only authenticated users can create bookings
    const user = await requireUser(ctx);
    
    const bookingId = await ctx.db.insert("bookings", {
      userId: user._id,
      ...args,
      status: "pending",
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });
    
    return bookingId;
  },
});

// Admin-only function
export const updateBookingStatus = mutation({
  args: {
    bookingId: v.id("bookings"),
    status: v.union(
      v.literal("confirmed"),
      v.literal("cancelled"),
      v.literal("completed")
    ),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    // Ensure only admins can update booking status
    await requireAdmin(ctx);
    
    await ctx.db.patch(args.bookingId, {
      status: args.status,
      updatedAt: Date.now(),
    });
    
    return null;
  },
});
```

### 3. Styling Guidelines

```css
/* src/styles/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    /* Shadcn CSS Variables - Light Mode */
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
    
    /* Custom theme colors */
    --brand-primary: 201 96% 32%;
    --brand-secondary: 198 93% 60%;
    --success: 142 76% 36%;
    --warning: 38 92% 50%;
    --info: 217 91% 60%;
  }
  
  .dark {
    /* Dark mode variables */
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    /* ... other dark mode variables */
  }
}

/* Component styling rules */
@layer components {
  /* Always use CSS variables */
  .btn-primary {
    @apply bg-primary text-primary-foreground hover:bg-primary/90;
  }
  
  /* Never hardcode colors */
  /* BAD: bg-blue-500 */
  /* GOOD: bg-primary */
  
  /* Consistent spacing */
  .page-container {
    @apply container mx-auto px-4 py-8 md:px-6 lg:px-8;
  }
  
  /* Responsive utilities */
  .responsive-grid {
    @apply grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4;
  }
}
```

## Security Best Practices

### 1. Backend Security
- Always validate user roles in Convex functions
- Use `requireUser` or `requireAdmin` helpers consistently
- Implement rate limiting for sensitive operations
- Log security events for auditing

### 2. Frontend Security
- Never trust client-side role checks alone
- Implement CSRF protection
- Use secure HTTP-only cookies for sessions
- Sanitize all user inputs

### 3. Data Security
- Encrypt sensitive data at rest
- Use HTTPS for all communications
- Implement proper CORS policies
- Regular security audits

## Testing Strategy

### 1. Unit Tests
- Test all validators and utility functions
- Test role-based access control logic
- Test authentication flows

### 2. Integration Tests
- Test complete user journeys
- Test role switching scenarios
- Test error handling

### 3. E2E Tests
- Test critical paths (sign up, sign in, booking)
- Test admin operations
- Test security boundaries

## Deployment Checklist

- [ ] Environment variables configured
- [ ] Email service (Resend) configured
- [ ] Database indexes optimized
- [ ] Security headers configured
- [ ] Rate limiting enabled
- [ ] Error tracking setup
- [ ] Monitoring and alerting configured
- [ ] Backup strategy implemented
- [ ] SSL certificates valid
- [ ] CORS policies reviewed

## Common Patterns

### 1. Form Handling
```typescript
// Always use controlled components with proper validation
const form = useForm<SignUpData>({
  resolver: zodResolver(signUpSchema),
  defaultValues: {
    email: "",
    password: "",
    name: "",
    role: "user",
  },
});
```

### 2. Error Handling
```typescript
// Use consistent error handling
try {
  await signIn("password", formData);
} catch (error) {
  if (error instanceof ConvexError) {
    toast.error(error.message);
  } else {
    toast.error("An unexpected error occurred");
  }
}
```

### 3. Loading States
```typescript
// Always show loading states
if (isLoading) {
  return <Skeleton className="h-full w-full" />;
}
```

## Maintenance Guidelines

1. **Regular Updates**
   - Keep dependencies updated
   - Review and update security policies
   - Monitor for deprecated APIs

2. **Code Reviews**
   - Enforce TypeScript strict mode
   - Check for proper role validation
   - Ensure consistent styling

3. **Documentation**
   - Keep API documentation current
   - Document all custom hooks
   - Maintain component storybook

This guide should be treated as a living document and updated as the application evolves.
